using System;
using System.IO;

namespace JMGBE.Core;

public class MMU
{
	public byte this[ushort index]
	{
		get => memory[index];
		set => memory[index] = value;
	}

	private static readonly byte[] bootrom = new byte[256]
	{
		0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
		0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
		0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
		0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
		0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
		0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
		0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
		0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
		0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
		0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
		0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
		0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
		0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
		0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
		0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
		0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
	};
	
	private byte[] cartridge_data = new byte[0x8000];

	private byte[] memory = new byte[0x10000];

	//Basic Read/Write functions.
	public byte ReadByte(int addr) 
	{
		System.Diagnostics.Debug.Assert(addr >= 0 && addr <= 0xFFFF);
		if (addr >= 0 && addr <= 0xFF)
			return memory[Registers.DBGROM] == 0 ? bootrom[addr] : cartridge_data[addr];
		return memory[addr];
	}
	public void WriteByte(int addr, byte value)
	{
		//The section [0x0000 - 0x7FFF] is ROM.
		System.Diagnostics.Debug.Assert(addr >= 0x8000 && addr <= 0xFFFF);
		//The section [0xFEA0 - 0xFEFF] is not usable.
		System.Diagnostics.Debug.Assert(!(addr >= 0xFEA0 && addr <= 0xFEFF));
		memory[addr] = value;
		if (addr >= 0xC000 && addr <= 0xDDFF)
			memory[addr + 0x2000] = value;
		else if (addr >= 0xE000 && addr <= 0xFDFF)
			memory[addr - 0x2000] = value;
	}
	//Complex Read/Write functions.
	public sbyte ReadSByte(int addr)
	{
		return (sbyte)ReadByte(addr);
	}
	public void LoadRom(string filename)
	{
		File.ReadAllBytes(filename).CopyTo(memory, 0);
		File.ReadAllBytes(filename).CopyTo(cartridge_data, 0);
	}
}

public static class Registers
{
	public const ushort JOYP	= 0xFF00;
	public const ushort LCDC	= 0xFF40;
	public const ushort STAT	= 0xFF41;
	public const ushort SCY		= 0xFF42;
	public const ushort SCX		= 0xFF43;
	public const ushort LY		= 0xFF44;
	public const ushort LYC		= 0xFF45;
	public const ushort DMA		= 0xFF46;
	public const ushort BGP		= 0xFF47;
	public const ushort OBP0	= 0xFF48;
	public const ushort OBP1	= 0xFF49;
	public const ushort WY		= 0xFF4A;
	public const ushort WX		= 0xFF4B;
	public const ushort DBGROM	= 0xFF50;
	public const ushort IE		= 0xFFFF;
}
